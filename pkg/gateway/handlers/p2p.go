package handlers

import (
	"errors"
	"io/ioutil"
	"net/http"

	"github.com/buger/jsonparser"
	"github.com/gorilla/mux"

	"github.com/gladiusio/gladius-common/pkg/blockchain"
	"github.com/gladiusio/gladius-common/pkg/handlers"
	"github.com/gladiusio/gladius-network-gateway/pkg/p2p/message"
	"github.com/gladiusio/gladius-network-gateway/pkg/p2p/peer"
	"github.com/gladiusio/gladius-network-gateway/pkg/p2p/signature"
	"github.com/gladiusio/gladius-network-gateway/pkg/p2p/state"
)

func parseSignedMessageFromBytes(smBytes []byte) (*signature.SignedMessage, error) {
	messageBytes, _, _, err := jsonparser.Get(smBytes, "message")
	if err != nil {
		return nil, errors.New("Can't find `message` in body")
	}

	hash, err := jsonparser.GetString(smBytes, "hash")
	if err != nil {
		return nil, errors.New("Can't find `hash` in body")
	}

	signatureString, err := jsonparser.GetString(smBytes, "signature")
	if err != nil {
		return nil, errors.New("Could not find `signature` in body")

	}

	address, err := jsonparser.GetString(smBytes, "address")
	if err != nil {
		return nil, errors.New("Could not find `address` in body")
	}

	parsed, err := signature.ParseSignedMessage(string(messageBytes), hash, signatureString, address)
	if err != nil {
		return nil, errors.New("Couldn't parse body")

	}

	return parsed, nil
}

// Helper to create signed message from body
func getSignedMessageFromBody(w http.ResponseWriter, r *http.Request) *signature.SignedMessage {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		handlers.ErrorHandler(w, r, "Error decoding body", err, http.StatusBadRequest)
		return nil
	}

	sm, err := parseSignedMessageFromBytes(body)

	if err != nil {
		handlers.ErrorHandler(w, r, "Error parsing signed message", err, http.StatusBadRequest)
	}

	return sm
}

// Helper to get fields from the json body and verify the signature
func verifyBody(w http.ResponseWriter, r *http.Request) (bool, *signature.SignedMessage) {
	parsed := getSignedMessageFromBody(w, r)
	if parsed == nil {
		return false, nil
	}
	verified := parsed.IsInPoolAndVerified()

	return verified, parsed
}

// Gets a content list from an incoming comparison request
func getContentListFromBody(w http.ResponseWriter, r *http.Request) []string {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		handlers.ErrorHandler(w, r, "Error decoding body", err, http.StatusBadRequest)
		return nil
	}
	s := make([]string, 0)
	// Get all content file names passed in
	jsonparser.ArrayEach(body, func(value []byte, dataType jsonparser.ValueType, offset int, err error) {
		s = append(s, string(value))
	}, "content")

	return s
}

// VerifySignedMessageHandler verifies the incoming message with takes the form
// of:
// {"message": "b64string", "hash": "b64string", "signature": "b64string", "address": ""}
func VerifySignedMessageHandler(w http.ResponseWriter, r *http.Request) {
	v, _ := verifyBody(w, r)
	if v {
		handlers.ResponseHandler(w, r, "Message is verified", true, nil, true, nil)
	} else {
		handlers.ResponseHandler(w, r, "Message is not verified", true, nil, false, nil)
	}
}

/*******************************************************************************
All methods below use the account generated by the gladius account manager
*******************************************************************************/

// CreateSignedMessageHandler takes the incoming message and returns a signed
// version that includes the timestamp.

func CreateSignedMessageHandler(ga *blockchain.GladiusAccountManager) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		body, err := ioutil.ReadAll(r.Body)
		if err != nil {
			handlers.ErrorHandler(w, r, "Error decoding body", err, http.StatusBadRequest)
			return
		}
		messageBytes, _, _, err := jsonparser.Get(body, "message")
		if err != nil {
			handlers.ErrorHandler(w, r, "Could not find `message` in body", err, http.StatusBadRequest)
			return
		}

		signed, err := signature.CreateSignedMessage(message.New(messageBytes), ga)
		if err != nil {
			handlers.ErrorHandler(w, r, "Could not create sign message. Wallet likely locked.", err, http.StatusBadRequest)
			return
		}

		handlers.ResponseHandler(w, r, "Created signed message", true, nil, signed, nil)
	}
}

func SetStateDebugHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		body, err := ioutil.ReadAll(r.Body)
		if err != nil {
			handlers.ErrorHandler(w, r, "Error decoding body", err, http.StatusBadRequest)
			return
		}

		toUpdate, _, _, err := jsonparser.Get(body, "state")
		if err != nil {
			handlers.ErrorHandler(w, r, "Could not find `state` in body", err, http.StatusBadRequest)
			return
		}
		s, _ := state.ParseNetworkState(toUpdate)
		p.SetState(s)

		handlers.ResponseHandler(w, r, "Updated state", true, nil, s, nil)
	}
}

// PushStateMessageHandler updates state with signed update and pushes state to
// a set of random peers. They then propigate it to their peers until the
// network has a consistent state
func PushStateMessageHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		v, sm := verifyBody(w, r)
		if v {
			err := p.UpdateAndPushState(sm)
			if err != nil {
				handlers.ErrorHandler(w, r, "Error updating state", err, http.StatusBadRequest)
			} else {
				handlers.ResponseHandler(w, r, "Message was pushed. This does not necessarily mean that the message was recieved by peers.", true, nil, true, nil)
			}
		} else {
			if sm != nil {
				handlers.ErrorHandler(w, r, "Cannot verifiy signature", errors.New("cannot verifiy signature"), http.StatusBadRequest)
			}
		}
	}
}

func getIntroductionDataFromBody(w http.ResponseWriter, r *http.Request) (ip string) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		handlers.ErrorHandler(w, r, "Error decoding body", err, http.StatusBadRequest)
		return ""
	}

	ip, err = jsonparser.GetString(body, "ip")
	if err != nil {
		handlers.ErrorHandler(w, r, "Could not find `ip` in body", err, http.StatusBadRequest)
		return ""
	}

	return ip
}

// JoinHandler takes in an IP and tries to join it's cluster
func JoinHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		ip := getIntroductionDataFromBody(w, r)
		if ip != "" {
			err := p.Join([]string{ip})
			if err != nil {
				handlers.ErrorHandler(w, r, "Couldn't join network", err, http.StatusBadRequest)
				return
			}
			handlers.ResponseHandler(w, r, "Requested to join pool", true, nil, nil, nil)
			return
		}
		handlers.ErrorHandler(w, r, "IP can't be empty", nil, http.StatusBadRequest)

	}
}

func LeaveHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		p.Stop()
		handlers.ResponseHandler(w, r, "Stopped Peer", true, nil, nil, nil)
	}
}

// GetFullStateHandler gets the current state the node has access to.
func GetFullStateHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		state := p.GetState()
		handlers.ResponseHandler(w, r, "Got full state", true, nil, state, nil)
	}
}

// GetNodeStateHandler gets the current state of a specific node
func GetNodeStateHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		vars := mux.Vars(r)
		na := vars["node_address"]
		nodeState, exists := p.GetState().NodeDataMap[na]
		if exists {
			handlers.ResponseHandler(w, r, "Got state for: "+na, true, nil, nodeState, nil)
			return
		}
		handlers.ErrorHandler(w, r, "That node doesn't exist", nil, http.StatusBadRequest)
	}
}

// GetSignatureListHandler gets the list of signatures used to create the current
// state
func GetSignatureListHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		handlers.ResponseHandler(w, r, "Fetched signature list. This can be used to rebuild a verified state.", true, nil, p.GetState().GetSignatureList(), nil)
	}
}

// GetContentNeededHandler compares the content provided with what is required by the
// pool and returns the deltas in the format website/<asset or route/filename
func GetContentNeededHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		c := getContentListFromBody(w, r)
		handlers.ResponseHandler(w, r, "Got needed content", true, nil, p.CompareContent(c), nil)
	}
}

// GetContentLinksHandler gets the links to the given list of files from random
// nodes in the network
func GetContentLinksHandler(p *peer.Peer) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		c := getContentListFromBody(w, r)
		handlers.ResponseHandler(w, r, "Got needed content links", true, nil, p.GetContentLinks(c), nil)
	}
}
